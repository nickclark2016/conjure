import { CppToolset, DOMNode, ExporterArguments, TextWriter, ToolsetRegistry, findProject, getAllDependencies, pathFromWorkspace, pathTo, pathToWorkspace } from "@conjure/core";
import { join, parse, relative } from "path";
import { Ninja } from "./utilities";

export const languageRule: any = {
    'C': 'cc',
    'C++': 'cxx',
}

function writeHeader(prj: DOMNode, cfg: DOMNode, _args: ExporterArguments, writer: TextWriter) {
    writer.write(`# Generated by Conjure`);
    writer.write(`# Project Build File for ${prj.getName()} - ${cfg.configuration}:${cfg.platform}`);
    writer.write('');
}

function writeRequiredVersion(_prj: DOMNode, _cfg: DOMNode, _args: ExporterArguments, writer: TextWriter) {
    writer.write('ninja_required_version = 1.6');
    writer.write('');
}

function writeCCompileRule(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {
    const toolset = (ToolsetRegistry.get().fetch(cfg.toolset) || ToolsetRegistry.get().fetch(prj.toolset)) as CppToolset;
    const defines: string[] = cfg.defines || [];
    const includes: string[] = cfg.includeDirs || [];
    const extIncludes: string[] = cfg.externalIncludeDirs || [];

    const base = (() => {
        try {
            return pathFromWorkspace(cfg);
        } catch (e) {
            return pathFromWorkspace(prj);
        }
    })();

    const cflags = toolset.getCFlags(cfg) || [];
    cflags.push(...toolset.getCppFlags(cfg));
    cflags.push(...defines.map(def => toolset.mapFlag('defines', def)));
    cflags.push(...includes.map(inc => toolset.mapFlag('includeDirs', join(base, inc))));
    cflags.push(...extIncludes.map(inc => toolset.mapFlag('externalIncludeDirs', join(base, inc))));

    const cc = toolset.toolname('compiler', cfg.language);

    writer.write(`CFLAGS = ${cflags.join(' ')}`);
    writer.write('rule cc');
    writer.indent();
    writer.write(`command = ${cc} $CFLAGS /nologo /showIncludes -c /Tc$in /Fo:$out`);
    writer.write(`description = cc $out`);
    if (toolset.name === 'msc') {
        writer.write(`deps = msvc`);
    }
    writer.outdent();
    writer.write('');
}

function writeCxxCompileRule(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {
    const toolset = (ToolsetRegistry.get().fetch(cfg.toolset) || ToolsetRegistry.get().fetch(prj.toolset)) as CppToolset;
    const defines: string[] = cfg.defines || [];
    const includes: string[] = cfg.includeDirs || [];
    const extIncludes: string[] = cfg.externalIncludeDirs || [];

    const base = (() => {
        try {
            return pathFromWorkspace(cfg);
        } catch (e) {
            return pathFromWorkspace(prj);
        }
    })();

    const cxxflags = toolset.getCxxFlags(cfg) || [];
    cxxflags.push(...toolset.getCppFlags(cfg));
    cxxflags.push(...defines.map(def => toolset.mapFlag('defines', def)));
    cxxflags.push(...includes.map(inc => toolset.mapFlag('includeDirs', join(base, inc))));
    cxxflags.push(...extIncludes.map(inc => toolset.mapFlag('externalIncludeDirs', join(base, inc))));

    const cxx = toolset.toolname('compiler', cfg.language);

    writer.write(`CXXFLAGS = ${cxxflags.join(' ')}`);
    writer.write('rule cxx');
    writer.indent();
    writer.write(`command = ${cxx} $CXXFLAGS /nologo /showIncludes -c /Tp$in /Fo:$out`);
    writer.write(`description = cxx $out`);
    writer.write(`deps = msvc`);
    writer.outdent();
    writer.write('');
}

function writeLinkCompileRule(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {
    const toolset = (ToolsetRegistry.get().fetch(cfg.toolset) || ToolsetRegistry.get().fetch(prj.toolset)) as CppToolset;

    const isArchive = cfg.kind === 'StaticLib';

    const linker = toolset.toolname(isArchive ? 'archive' : 'compiler', cfg.language);
    const links: string[] = [];

    const base = (() => {
        try {
            return pathFromWorkspace(cfg);
        } catch (e) {
            return pathFromWorkspace(prj);
        }
    })();

    cfg.libraryDirs = (cfg.libraryDirs || []).map((dir: string) => {
        return join(base, dir);
    });

    const projectDeps: DOMNode[] = getAllDependencies(prj);
    projectDeps.forEach(depPrj => {
        if (depPrj) {
            const depTargetCfg = depPrj.getChildren().find(flt => flt.platform === cfg.platform && flt.configuration === cfg.configuration);
            if (depTargetCfg) {
                const base = (() => {
                    try {
                        return pathFromWorkspace(depTargetCfg);
                    } catch (e) {
                        return pathFromWorkspace(depPrj);
                    }
                })();

                const toLibFromDep = join(base, depTargetCfg.targetDirectory);
                const targetName = `${depPrj.getName()}${toolset.mapFlag('targetExtension', 'StaticLib')}`;
                if (depPrj.kind === 'StaticLib' || depPrj.kind === 'SharedLib') {
                    cfg.libraryDirs.push(toLibFromDep);
                    links.push(targetName);
                }
            }
        }
    });

    cfg.libraryDirs = [...new Set(cfg.libraryDirs)];

    const linkFlags = toolset.getLinkFlags(cfg) || [];
    if (prj.kind === 'SharedLib') {
        linkFlags.push('/link');
    }

    const needsImpLib = cfg.kind === 'SharedLib';
    if (needsImpLib) {
        
    }

    writer.write(`LINKFLAGS = ${linkFlags.join(' ').trim()}`);
    writer.write('rule link');
    writer.indent();
    if (isArchive) {
        writer.write(`command = ${linker} $in $LINKFLAGS /out:$out`);
        writer.write(`description = link $out`);
    } else if (cfg.kind === 'SharedLib') {
        writer.write(`command = ${linker} /LD $in $LINKFLAGS ${links.join(' ').trim()} /IMPLIB:$import /out:$out`);
        writer.write(`description = link $out`);
    } else {
        writer.write(`command = ${linker} $in $LINKFLAGS ${links.join(' ').trim()} /out:$out`);
        writer.write(`description = link $out`);
    }
    writer.outdent();
    writer.write('');
}

function writeFiles(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {
    const toolset = (ToolsetRegistry.get().fetch(cfg.toolset) || ToolsetRegistry.get().fetch(prj.toolset)) as CppToolset;
    const intDir: string = cfg.intermediateDirectory || join(`obj`, cfg.platform, cfg.configuration);

    const files = [...(prj.inputFiles || []), ...(cfg.inputFiles || [])];
    const base = (() => {
        try {
            return pathFromWorkspace(cfg);
        } catch (e) {
            return pathFromWorkspace(prj);
        }
    })();

    files.forEach(file => {
        const language = Ninja.determineLanguage(file);
        if (language) {
            const rule = languageRule[language];
            if (rule) {
                const intermediate = `${parse(file).name}${toolset.mapFlag('intermediateExtension', '')}`;
                const path = join(base, intDir, intermediate);
                const fullPath = join(base, file);
                writer.write(`build ${path}: ${rule} ${fullPath}`);
            } else {
                console.warn(`Failed to find rule for language: ${language}`);
            }
        }
    });
    writer.write('');
}

function writeOutputs(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {
    const toolset = (ToolsetRegistry.get().fetch(cfg.toolset) || ToolsetRegistry.get().fetch(prj.toolset)) as CppToolset;
    const intDir: string = cfg.intermediateDirectory || join(`obj`, cfg.platform, cfg.configuration);

    writer.write(`# Link ${prj.getName()}`);

    const base = (() => {
        try {
            return pathFromWorkspace(cfg);
        } catch (e) {
            return pathFromWorkspace(prj);
        }
    })();

    const files = [...(prj.inputFiles || []), ...(cfg.inputFiles || [])];
    const ints = new Set(files.filter(file => Ninja.determineLanguage(file) !== undefined).map(file => {
        const intermediate = `${parse(file).name}${toolset.mapFlag('intermediateExtension', '')}`;
        const path = join(base, intDir, intermediate);
        return path;
    }));

    const targetDir = cfg.targetDirectory ? join(base, cfg.targetDirectory) : prj.targetDirectory ? join(base, prj.targetDirectory) : join(base, `bin`, cfg.platform, cfg.configuration);
    const targetPath = join(targetDir, `${prj.getName()}${toolset.mapFlag('targetExtension', cfg.kind)}`);

    const deps = getAllDependencies(cfg).map(dep => `${dep.getName()}_${cfg.configuration}_${cfg.platform}`);
    const depString = deps.length > 0 ? `| ${deps.join(' ')}` : ''

    writer.write(`build ${targetPath}: link ${[...ints].join(' ')} ${depString}`);
    if (prj.kind === 'SharedLib') {
        writer.indent();
        writer.write(`import = ${join(targetDir, `${prj.getName()}${toolset.mapFlag('targetExtension', 'StaticLib')}`)}`)
        writer.outdent();
    }

    writer.write('');
}

function writePhonies(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {
    const toolset = (ToolsetRegistry.get().fetch(cfg.toolset) || ToolsetRegistry.get().fetch(prj.toolset)) as CppToolset;

    writer.write(`# Build Phonies`);

    const base = (() => {
        try {
            return pathFromWorkspace(cfg);
        } catch (e) {
            return pathFromWorkspace(prj);
        }
    })();

    const targetDir = cfg.targetDirectory ? join(base, cfg.targetDirectory) : join(base, `bin`, cfg.platform, cfg.configuration);
    const targetPath = join(targetDir, `${prj.getName()}${toolset.mapFlag('targetExtension', cfg.kind)}`);

    writer.write(`build ${prj.getName()}_${cfg.configuration}_${cfg.platform}: phony ${targetPath}`);

    writer.write('');
}

export type PerProjectConfig = (prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) => void;

export const perProjectConfigFunctions: PerProjectConfig[] = [
    writeHeader,
    writeRequiredVersion,
    writeCCompileRule,
    writeCxxCompileRule,
    writeLinkCompileRule,
    writeFiles,
    writeOutputs,
    writePhonies,
];

export function cppProject(prj: DOMNode, args: ExporterArguments) {
    const filters = prj.getChildren().filter(flt => flt.apiName === 'when');
    filters.forEach(flt => {
        const config = flt.configuration;
        const platform = flt.platform;

        const path = join(prj.location, `${prj.getName()}_${config}_${platform}.ninja`);
        const writer = new TextWriter(path);
        writer.useSpaceIndent(2);

        perProjectConfigFunctions.forEach(fn => fn(prj, flt, args, writer));

        writer.close();
    });
}