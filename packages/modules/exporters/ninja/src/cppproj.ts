import { DOMNode, ExporterArguments, TextWriter, ToolsetRegistry, pathFromWorkspace, pathToWorkspace } from "@conjure/core";
import { extname, join, parse } from "path";

type PerProjectWrite = (prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) => void;

function writeHeader(prj: DOMNode, cfg: DOMNode, _args: ExporterArguments, writer: TextWriter) {
    writer.write(`# Generated by Conjure`);
    writer.write(`# Project - ${prj.getName()}`);
    writer.write('');
}

function writeCompileRule(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {   
    writer.write(`# Build rules`);
    writer.write(`rule ${prj.getName()}_cc`);
    writer.indent()
    writer.write(`command = ni $out`)
    writer.outdent();
    writer.write('');

    let rootPath = pathFromWorkspace(prj);
    cfg.__buildState.intermediates = [];
    
    const sources = new Set([prj, cfg].flatMap(node => {
        try {
            rootPath = pathFromWorkspace(node);
        } catch (e) {}

        return (node.inputFiles || []).filter((file: string) => {
            const extension = extname(file);
            return extension === '.cpp';
        }).map((path: string) => {
            return join(rootPath, path);
        });
    }));

    sources.forEach(src => {
        const name = parse(src).name;
        const intermediateDirectory = cfg.intermediateDirectory || 'obj';
        const outputLocation = join(rootPath, intermediateDirectory, `${name}.o`);
        cfg.__buildState.intermediates.push(outputLocation);
        writer.write(`build ${outputLocation}: ${prj.getName()}_cc ${src}`);
    });
    writer.write('');
}

function writeLinkRules(prj: DOMNode, cfg: DOMNode, args: ExporterArguments, writer: TextWriter) {
    writer.write(`# Link rules`);
    writer.write(`rule ${prj.getName()}_link`);
    writer.indent()
    writer.write(`command = ni $out"`)
    writer.outdent();
    writer.write('');

    const ints: string[] = cfg.__buildState.intermediates || [];
    let outputLocation = join(cfg.targetDirectory || prj.targetDirectory || 'bin', prj.getName());
    let wksLocation = pathFromWorkspace(prj);
    
    try {
        wksLocation = pathFromWorkspace(cfg);
    } catch (e) {}

    outputLocation = join(wksLocation, outputLocation);

    let name = `${cfg.targetname || prj.getName()}`;
    if (cfg.targetExt) {
        name = `${name}.${cfg.targetExt}`;
    }

    cfg.__buildState.outputLocation = outputLocation;
    cfg.__buildState.outputName = name;
    cfg.__buildState.outputPath = join(outputLocation, cfg.__buildState.outputName);

    writer.write(`build ${outputLocation}: ${prj.getName()}_link ${ints.join(' ')}`);
    writer.write('');
}

export const projectFunctionArray: PerProjectWrite[] = [
    writeHeader,
    writeCompileRule,
    writeLinkRules,
];

export function cppproj(prj: DOMNode, cfg: DOMNode, args: ExporterArguments) {
    const prjFileLocation = join(prj.location, `${prj.getName()}_${cfg.configuration}_${cfg.platform}.ninja`);
    const writer = new TextWriter(prjFileLocation);
    writer.useSpaceIndent(2);
    cfg.__buildState = {};
    projectFunctionArray.forEach(fn => fn(prj, cfg, args, writer));
    writer.close();
}