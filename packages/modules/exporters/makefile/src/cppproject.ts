import { DOMNode, ExporterArguments, TextWriter, ToolsetRegistry, include } from "@conjure/core";
import { basename, extname, join } from "path";
import { fetchConfigName, makeEscape, writeShell } from "./utils";

const extensions: any = {
    windows: {
        StaticLib: '.lib',
        SharedLib: '.dll',
        ConsoleApp: '.exe',
        WindowsApp: '.exe'
    },
    linux: {
        StaticLib: '.a',
        SharedLib: '.so',
        ConsoleApp: ''
    }
};

const files: any = {
    sources: [
        '.c',
        '.cc',
        '.cpp',
        '.cxx',
    ]
}

function determineTool(ext: string) {
    if (ext === '.c') {
        return 'CC';
    } else if (ext === '.cc' || ext === '.cpp' || ext === '.cxx') {
        return 'CXX';
    } else {
        console.log(`Unexpected file extention: ${ext}`);
    }
}

function gatherCommonFlags(cfg: DOMNode, _args: ExporterArguments) {
    const toolset = ToolsetRegistry.get().fetch(cfg.toolset);
    const arch = toolset?.mapFlag('architecture', cfg.platform) || '';
    const opts = toolset?.mapFlag('optimize', cfg.optimize || 'On') || '';
    const debug = toolset?.mapFlag('symbols', cfg.symbols) || '';
    return [arch, opts, debug].filter(flag => flag.length > 0).join(' ');
}

function writeHeader(node: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write(`# Makefile generated by Conjure for project ${node.getName()}`);
    file.write("");
}

function writeVerbose(node: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('ifndef verbose');
    file.indent();
    file.write('SILENT = @');
    file.outdent();
    file.write('endif');
    file.write("");
}

function writePhonies(_: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('.PHONY: clean');
    file.write("");
}

function writeSets(_: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('# File Sets')
    file.write('GENERATED :=');
    file.write('OBJECTS :=');
    file.write("");
}

function writeFileRules(node: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('# File Rules');
    file.write("");
    node.inputFiles.filter((f: string) => {
        const ext = extname(f);
        return files.sources.includes(ext);
    }).forEach((f: string) => {
        const extension = extname(f);
        const toolname = determineTool(extension);
        const nameNoExt = makeEscape(basename(f, extension));
        file.write(`$(OBJDIR)/${nameNoExt}.o: ${makeEscape(f)}`);
        file.indent();
        file.write('@echo $(notdir $<)');
        file.write(`$(SILENT) $(${toolname}) $(${toolname === 'CC' ? 'ALL_CFLAGS' : 'ALL_CXXFLAGS'}) -o "$@" -MF "$(@:%.o=%.d)" -d "$<"`);
        file.outdent();
        file.write("");
    });
}

function writeAll(_: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('all: $(TARGET)');
    file.write('\t@echo "Hello, World!"');
    file.write("");
}

function writeTarget(_: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('$(TARGET): $(TARGETDIR)');
    file.indent();
    file.write('@echo Executing Target');
    file.outdent();
    file.write("");
}

function writeTargetDir(_: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('$(TARGETDIR):');
    file.indent();
    file.write('@echo Creating $(TARGETDIR)');
    file.outdent();
    file.write('ifeq (posix,$(SHELLTYPE))');
    file.indent();
    file.write('$(SILENT) mkdir -p $(TARGETDIR)');
    file.outdent();
    file.write('else');
    file.indent();
    file.write('$(SILENT) mkdir $(subst /,\\,$(TARGETDIR))');
    file.outdent();
    file.write('endif');
    file.write("");
}

function writeObjDir(_: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('$(OBJDIR):');
    file.indent();
    file.write('@echo Creating $(OBJDIR)');
    file.outdent();
    file.write('ifeq (posix,$(SHELLTYPE))');
    file.indent();
    file.write('$(SILENT) mkdir -p $(OBJDIR)');
    file.outdent();
    file.write('else');
    file.indent();
    file.write('$(SILENT) mkdir $(subst /,\\,$(OBJDIR))');
    file.outdent();
    file.write('endif');
    file.write("");
}

function writeGlobals(_: DOMNode, file: TextWriter, _args: ExporterArguments) {
    file.write('RESCOMP :=');
    file.write('DEFINES :=');
    file.write('INCLUDES :=');
    file.write('ALL_CPPFLAGS :=');
    file.write('ALL_CFLAGS :=');
    file.write('ALL_CXXFLAGS :=');
    file.write('ALL_RESFLAGS :=');
    file.write('ALL_LDFLAGS :=');
    file.write('LINKCMD :=');
    file.write('LIBS :=');
    file.write('LDDEPS :=')
    file.write("");
}

function writeConfigurations(prj: DOMNode, file: TextWriter, args: ExporterArguments) {
    const configurations = prj.getChildren().filter(cfg => cfg.apiName === 'when');

    for (let i = 0; i < configurations.length; ++i) {
        const cfg = configurations[i];
        const configName = fetchConfigName(cfg);

        if (i == 0) {
            file.write(`ifeq ($(config),${configName})`);
        } else {
            file.write(`else ifeq  ($(config),${configName})`)
        }

        cpp.perConfig.forEach(cb => cb(cfg, file, args));
        file.write("");
    }
    
    file.write('endif');
    file.write("");
}

function writeConfigDefines(cfg: DOMNode, file: TextWriter, _args: ExporterArguments) {
    const defines: string[] = cfg.defines || [];
    const toolset = ToolsetRegistry.get().fetch(cfg.toolset);
    file.write(`DEFINES += ${defines.map(def => `${toolset?.mapFlag('defines', def)}`).join(' ')}`);
}

function writeConfigIncludes(cfg: DOMNode, file: TextWriter, _args: ExporterArguments) {
    const includes: string[] = cfg.includeDirs || [];
    const toolset = ToolsetRegistry.get().fetch(cfg.toolset);
    file.write(`INCLUDES += ${makeEscape(includes.map(inc => toolset?.mapFlag('includeDirs', inc)).join(' '))}`);
}

function writeTargets(cfg: DOMNode, file: TextWriter, args: ExporterArguments) {
    const targetDir = makeEscape(cfg.targetDirectory || 'bin');
    const intDir = makeEscape(cfg.intermediateDirectory || 'obj');
    file.write(`TARGETDIR = ${targetDir}`);
    file.write(`TARGET = $(TARGETDIR)/${makeEscape(cfg.targetName || cfg.getParent()?.getName())}${extensions[args.system][cfg.kind]}`);
    file.write(`OBJDIR = ${intDir}`);
}

function writeCppFlags(cfg: DOMNode, file: TextWriter, args: ExporterArguments) {
    const toolset = ToolsetRegistry.get().fetch(cfg.toolset);
    const cppFlags = toolset?.mapFlag('commonSystemFlags', args.system);
    const allCppflags = `ALL_CPPFLAGS += $(CPPFLAGS) ${cppFlags} $(DEFINES) $(INCLUDES)`
    file.write(allCppflags);
}

function writeCFlags(cfg: DOMNode, file: TextWriter, args: ExporterArguments) {
    const toolset = ToolsetRegistry.get().fetch(cfg.toolset);
    const common = gatherCommonFlags(cfg, args);
    const version = toolset?.mapFlag('cVersion', cfg.languageVersion) || '';
    const flags = [common, version].filter(flag => flag.length > 0).join(' ');
    file.write(`ALL_CFLAGS += $(CFLAGS) $(ALL_CPPFLAGS) ${flags}`);
}

function writeCxxFlags(cfg: DOMNode, file: TextWriter, args: ExporterArguments) {
    const toolset = ToolsetRegistry.get().fetch(cfg.toolset);
    const common = gatherCommonFlags(cfg, args);
    const version = toolset?.mapFlag('cppVersion', cfg.languageVersion) || '';
    const flags = [common, version].filter(flag => flag.length > 0).join(' ');
    file.write(`ALL_CXXFLAGS += $(CXXFLAGS) $(ALL_CPPFLAGS) ${flags}`);
}

function writeLinkerFlags(cfg: DOMNode, file: TextWriter, args: ExporterArguments) {
    const toolset = ToolsetRegistry.get().fetch(cfg.toolset);
    const arch = toolset?.mapFlag('architecture', cfg.platform) || '';
    const defaultLibDir = toolset?.mapFlag('libraryDirs', toolset?.mapFlag('defaultLibraryDirectory', cfg.platform)) || '';
    const linkerSymbols = toolset?.mapFlag('linkerSymbols', cfg.symbols) || '';
    const flags = [arch, defaultLibDir, linkerSymbols].filter(flag => flag.length > 0).join(' ');
    file.write(`ALL_LDFLAGS += $(LDFLAGS) ${flags}`);
}

export const cpp = {
    perConfig: [
        writeTargets,
        writeConfigDefines,
        writeConfigIncludes,
        writeCppFlags,
        writeCFlags,
        writeCxxFlags,
        writeLinkerFlags
    ],
    perProject: [
        writeHeader,
        writeVerbose,
        writeShell,
        writePhonies,
        writeGlobals,
        writeConfigurations,
        writeSets,
        writeAll,
        writeTarget,
        writeTargetDir,
        writeFileRules,
    ]
};

export function cppProject(node: DOMNode, args: ExporterArguments) {
    const wksFileLocation = join(node.location, node.__makefile_name);
    node.__fileLocation = wksFileLocation;

    const file = new TextWriter(wksFileLocation);

    cpp.perProject.forEach(step => step(node, file, args));

    file.close();
}